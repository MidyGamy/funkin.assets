import funkin.play.character.SparrowCharacter;
import funkin.play.PlayState;
import flixel.FlxG;
import flixel.FlxSprite;
import flixel.util.FlxTimer;
import flixel.group.FlxTypedSpriteGroup;
import funkin.graphics.FunkinSprite;
import funkin.play.character.CharacterDataParser;
import funkin.modding.base.ScriptedFlxAtlasSprite;
import funkin.modding.base.ScriptedFlxSprite;
import funkin.modding.base.ScriptedFlxSpriteGroup;
import funkin.graphics.adobeanimate.FlxAtlasSprite;
import funkin.util.FlxColorUtil;
import funkin.audio.visualize.ABotVis;

class NeneDarkCharacter extends SparrowCharacter {
	function new() {
		super('nene-dark');
	}

	var normalChar:BaseCharacter;

	var pupilState:Int = 0;

	var PUPIL_STATE_NORMAL = 0;
	var PUPIL_STATE_LEFT = 1;

	var abot:FlxSpriteGroup;


	override function set_alpha(val:Float):Float{
		super.set_alpha(val);
		if(val != 1)
			normalChar.alpha = 1;
		else
			normalChar.alpha = 0;

		if(abot != null)
		{
			abot.scriptGet('testShader').amount = val;
			abot.scriptGet('eyeWhites').color = FlxColorUtil.interpolate(0xFFFFFFFF, 0xFF6F96CE, val);
		}

    return val;
	}

	function onCreate(event:ScriptEvent) {
		super.onCreate(event);

    // abot = ScriptedFlxSpriteGroup.init('AbotSpeaker', -100, 216, this);
		// FlxG.debugger.track(abot);
		// abot.scriptCall("setupDarkShaders");

		normalChar = CharacterDataParser.fetchCharacter('nene');
    normalChar.zIndex = this.zIndex - 1;
		normalChar.alpha = 0;
    normalChar.flipX = false;
	}

	override function onAdd() {

			abot = normalChar.scriptGet("abot"); //why should I create a new one when this one alreary exists?
			// abot.zIndex = this.zIndex - 10;
			// PlayState.instance.currentStage.add(abot);
			abot.scriptCall("setupDarkShaders");
			abot.scriptSet("character", this);
			trace(abot.scriptGet("character"));
			abot.scriptCall("refreshPoses");
	}

	/**
	 * At this amount of life, Nene will raise her knife.
	 */
	var VULTURE_THRESHOLD = 0.25 * 2;

	/**
	 * Nene is in her default state. 'danceLeft' or 'danceRight' may be playing right now,
	 * or maybe her 'combo' or 'drop' animations are active.
	 *
	 * Transitions:
	 * If player health <= VULTURE_THRESHOLD, transition to STATE_PRE_RAISE.
	 */
	var STATE_DEFAULT = 0;

	/**
	 * Nene has recognized the player is at low health,
	 * but has to wait for the appropriate point in the animation to move on.
	 *
	 * Transitions:
	 * If player health > VULTURE_THRESHOLD, transition back to STATE_DEFAULT without changing animation.
	 * If current animation is combo or drop, transition when animation completes.
	 * If current animation is danceLeft, wait until frame 14 to transition to STATE_RAISE.
	 * If current animation is danceRight, wait until danceLeft starts.
	 */
	var STATE_PRE_RAISE = 1;

	/**
	 * Nene is raising her knife.
	 * When moving to this state, immediately play the 'raiseKnife' animation.
	 *
	 * Transitions:
	 * Once 'raiseKnife' animation completes, transition to STATE_READY.
	 */
	var STATE_RAISE = 2;

	/**
	 * Nene is holding her knife ready to strike.
	 * During this state, hold the animation on the first frame, and play it at random intervals.
	 * This makes the blink look less periodic.
	 *
	 * Transitions:
	 * If the player runs out of health, move to the GameOverSubState. No transition needed.
	 * If player health > VULTURE_THRESHOLD, transition to STATE_LOWER.
	 */
	var STATE_READY = 3;

	/**
	 * Nene is raising her knife.
	 * When moving to this state, immediately play the 'lowerKnife' animation.
	 *
	 * Transitions:
	 * Once 'lowerKnife' animation completes, transition to STATE_DEFAULT.
	 */
	var STATE_LOWER = 4;

	/**
	 * Nene's animations are tracked in a simple state machine.
	 * Given the current state and an incoming event, the state changes.
	 */
	var currentState:Int = STATE_DEFAULT;

	/**
	 * Nene blinks every X beats, with X being randomly generated each time.
	 * This keeps the animation from looking too periodic.
	 */
	var MIN_BLINK_DELAY:Int = 3;
	var MAX_BLINK_DELAY:Int = 7;
	var blinkCountdown:Int = MIN_BLINK_DELAY;

	override function playAnimation(name:String, restart:Bool, ignoreOther:Bool) {
			super.playAnimation(name, restart, ignoreOther);
	}

	function dance(forceRestart:Bool) {
		// Then, perform the appropriate animation for the current state.
		switch(currentState) {
			case STATE_DEFAULT:
				if (hasDanced) {
					playAnimation('danceRight', forceRestart);
				} else {
					playAnimation('danceLeft', forceRestart);
				}
				hasDanced = !hasDanced;
			case STATE_PRE_RAISE:
				playAnimation('danceLeft', false);
				hasDanced = false;
			case STATE_READY:
				if (blinkCountdown == 0) {
					playAnimation('idleKnife', false);
					blinkCountdown = FlxG.random.int(MIN_BLINK_DELAY, MAX_BLINK_DELAY);
				} else {
					blinkCountdown--;
				}
			default:
				// In other states, don't interrupt the existing animation.
		}
	}

	override public function update(elapsed:Float) {
		super.update(elapsed);
	}

	function onUpdate(event:UpdateScriptEvent) {
		super.onUpdate(event);

		if (shouldTransitionState()) {
			transitionState();
		}
	}

	public function onScriptEvent(event:ScriptEvent):Void {
		if(abot != null)
			abot.scriptCall('onScriptEvent', [event]);
		super.onScriptEvent(event);
	}

  override function draw()
  {
		if(!visible)
			return;
		if(abot != null)
    	abot.draw();
		if(normalChar != null)
			normalChar.draw();
    super.draw();
  }

	var animationFinished:Bool = false;

	function onAnimationFinished(name:String) {
		super.onAnimationFinished(name);

		switch(currentState) {
			case STATE_RAISE:
				if (name == "raiseKnife") {
					animationFinished = true;
					transitionState();
				}
			case STATE_LOWER:
				if (name == "lowerKnife") {
					animationFinished = true;
					transitionState();
				}
			default:
				// Ignore.
		}
	}

	function onAnimationFrame(name:String, frameNumber:Int, frameIndex:Int) {
		super.onAnimationFrame(name, frameNumber, frameIndex);
		if(normalChar != null){
			if(normalChar.animation.curAnim.name != name)
				normalChar.playAnimation(name);
			normalChar.animation.curAnim.curFrame = frameNumber;
			normalChar.setPosition(this.x, this.y);
		}

		switch(currentState) {
			case STATE_PRE_RAISE:
				if (name == "danceLeft" && frameNumber == 13) {
					animationFinished = true;
					transitionState();
				}
			default:
				// Ignore.
		}
	}

	function shouldTransitionState():Bool {
		return PlayState.instance.currentStage.getBoyfriend().characterId != "pico-blazin";
	}

	function transitionState() {
		switch (currentState) {
			case STATE_DEFAULT:
				if (PlayState.instance.health <= VULTURE_THRESHOLD) {
					// trace('NENE: Health is low, transitioning to STATE_PRE_RAISE');
					currentState = STATE_PRE_RAISE;
				} else {
					currentState = STATE_DEFAULT;
				}
			case STATE_PRE_RAISE:
				if (PlayState.instance.health > VULTURE_THRESHOLD) {
					// trace('NENE: Health went back up, transitioning to STATE_DEFAULT');
					currentState = STATE_DEFAULT;
				} else if (animationFinished) {
					// trace('NENE: Animation finished, transitioning to STATE_RAISE');
					currentState = STATE_RAISE;
					playAnimation('raiseKnife');
					animationFinished = false;
				}
			case STATE_RAISE:
				if (animationFinished) {
					// trace('NENE: Animation finished, transitioning to STATE_READY');
					currentState = STATE_READY;
					animationFinished = false;
				}
			case STATE_READY:
				if (PlayState.instance.health > VULTURE_THRESHOLD) {
					// trace('NENE: Health went back up, transitioning to STATE_LOWER');
					currentState = STATE_LOWER;
					playAnimation('lowerKnife');
				}
			case STATE_LOWER:
				if (animationFinished) {
					// trace('NENE: Animation finished, transitioning to STATE_DEFAULT');
					currentState = STATE_DEFAULT;
					animationFinished = false;
				}
			default:
				// trace('UKNOWN STATE ' + currentState);
				currentState = STATE_DEFAULT;
		}
	}
}
